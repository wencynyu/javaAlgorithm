package top.yuwenxin.leetcode.dp;

import java.util.Scanner;

/**
 * TSP旅行商问题：原点出发，经过所有节点，最后要回到原点，求最小花费
 * 输入：城市间的车票价钱 n行n列的矩阵 cost[n][n]
 * 输出：最小花费
 */
public class TravelingSalesmanProblem {
    // todo:理解旅行商问题
    public int tsp(int[][] cost) {
        int n = cost.length;
        int V = 1 << (n - 1);// 对1进行左移n-1位，值刚好等于2^(n-1)
        // dp表，n行，2^(n-1)列
        int[][] dp = new int[n][V];
        // 初始化dp表第一列
        for (int i = 0; i < n; i++) {
            dp[i][0] = cost[i][0];
        }

        // 设想一个数组城市子集V[j]，长度为V,且V[j] = j,对于V[j]即为压缩状态的城市集合
        // j的二进制表示城市相应城市是否在子集中
        for (int j = 1; j < V; j++){
            for (int i = 0; i < n; i++) { // 这个i不仅代表城市号，还代表第i次迭代
                dp[i][j] = Integer.MAX_VALUE; // 为了方便求最小值,先将其设为最大值
                if (((j >> (i - 1)) & 1) == 0) {
                    // 因为j就代表城市子集V[j],((j >> (i - 1))是把第i号城市取出来
                    // 并位与上1，等于0，说明是从i号城市出发，经过城市子集V[j]，回到起点0号城市
                    for (int k = 1; k < n; k++) { // 这里要求经过子集V[j]里的城市回到0号城市的最小距离
                        if (((j >> (k - 1)) & 1) == 1) { // 遍历城市子集V[j]
                            //设s=j ^ (1 << (k - 1))
                            //dp[k][j ^ (1 << (k - 1))，是将dp定位到，从k城市出发，经过城市子集V[s]，回到0号城市所花费的最小距离
                            //怎么定位到城市子集V[s]呢，因为如果从k城市出发的，经过城市子集V[s]的话
                            //那么V[s]中肯定不包含k了，那么在j中把第k个城市置0就可以了，而j ^ (1 << (k - 1))的功能就是这个
                            dp[i][j] = Math.min(dp[i][j], cost[i][k] + dp[k][j ^ (1 << (k - 1))]); //^异或
                        }
                    }
                }
            }
        }
        return dp[0][V - 1];
    }
}

/**
 * 动态规划模型构造
 * 对于4个城市的情况
 * 城市的邻接表如下：
 * S0  S1   S2     S3
 * S0   0   3    6     7
 * S1   5   0    2     7
 * S2   6   6    0     2
 * S3   3   3    5     0
 * 假设找出的一条最短的回路：S0->S1->S2->S3->S0
 * 我们可以利用结论： "S1 S2 S3 S0 "必然是从S1到S0通过其它各点的一条最短路径(如果不是，则会出现矛盾)
 * Length(总回路) = Length(S0，S1)  + Length(S1,S2,S3,S0)
 * <p>
 * 从上面的公式把总回路长度分解：
 * Length(回路) =Min{ Length(0,1)+Length(1,…,0)，Length(0,2)+Length(2,…,0)，Length(0,3)+Length(3,…,0)}
 * 规范化地表达上面的公式
 * d(i，V) 表示从i点经过点集Ｖ各点一次之后回到出发点的最短距离
 * d(i，V') ＝ min {Cik+d(k,V－{k})}   (k∈V')
 * d(k，{ }) ＝ Cik (k≠i)
 * 其中，Ｃik表示i到k的距离
 * 从城市0出发，经城市1、2、3然后回到城市0的最短路径长度是：
 * d(0, {1, 2, 3})=min{C01+ d(1, { 2, 3}), C02+ d(2, {1, 3}),C03+ d(3, {1, 2})}
 * <p>
 * 这是最后一个阶段的决策，它必须依据d(1, { 2, 3})、
 * d(2, {1, 3})和d(3, {1, 2})的计算结果,而：
 * <p>
 * d(1, {2, 3})=min{C12+d(2, {3}), 　C13+ d(3, {2})}
 * d(2, {1, 3})=min{C21+d(1, {3}), 　C23+ d(3, {1})}
 * d(3, {1, 2})=min{C31+d(1, {2}), 　C32+ d(2, {1})}
 * 继续写下去：
 * d(1, {2})= C12+d(2, {})   d(2, {3})=C23+d(3, {})   d(3, {2})= C32+d(2, {})
 * d(1, {3})= C13+d(3, {})   d(2, {1})=C21+d(1, {})   d(3, {1})= C31+d(1, {})
 * <p>
 * 建立dp表
 */
//注意:经过的路线是一条经过所有城市的闭合回路, 因此从哪一点出发是无所谓的, 因此不妨设从城市0出发。